// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum RitualStatus {
  PLANNED // antes do check-in noturno
  COMPLETED // respondeu "Sim"
  MISSED // respondeu "Não"
}

enum Language {
  pt_BR
  en_US
  es_ES
}

enum AiRole {
  USER
  ASSISTANT
  SYSTEM
}

model User {
  id          String   @id @default(cuid())
  email       String?  @unique // opcional para login social
  displayName String?
  nickname    String? // "apelido" no app
  locale      Language @default(en_US)
  timezone    String // ex: "America/Fortaleza"

  isAnonymous Boolean @default(true) // se true, usuário temporário (sem conta)

  // Preferências do ritual
  checkInHour   Int     @default(20) // 0..23 hora local para notificação
  checkInMinute Int     @default(0) // 0..59
  soundEnabled  Boolean @default(false)
  soundId       String? // FK (AmbientSound.id) opcional

  // Relacionamentos
  rituals RitualDay[]
  notes   Note[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  sound       AmbientSound? @relation(fields: [soundId], references: [id])
  aiThreads   AiThread[]
  pushDevices PushDevice[]
}

model AmbientSound {
  id     String  @id @default(cuid())
  key    String  @unique // ex: "rain", "forest", "white_noise"
  title  String
  // URL do asset (pode ser CDN ou path relativo do app)
  url    String
  active Boolean @default(true)

  users User[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model RitualDay {
  id        String   @id @default(cuid())
  userId    String
  // data local do usuário (sem horário) para garantir unicidade por dia
  localDate DateTime @db.Date
  // também guardamos timestamps absolutos em UTC para auditoria
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  archived  Boolean? @default(false) // quando arquivado ("apagado"), não aparece em nenhuma das telas do app

  // Momento da manhã ("Hoje eu vou…")
  title  String // objetivo principal do dia
  note   String? // nota opcional
  status RitualStatus @default(PLANNED)

  // Check-in noturno
  checkInAt DateTime? // quando respondeu
  achieved  Boolean? // null=sem resposta, true/false=sim/não
  aiReply   String? // 2–4 frases empáticas
  microStep String? // sugestão curta para amanhã

  // marca se o “prazo de 24h” já venceu
  pastDue Boolean @default(false)

  // Subtarefas
  subtasks Subtask[]

  user User @relation(fields: [userId], references: [id])

  @@unique([userId, localDate]) // 1 ritual por dia por usuário
  @@index([userId, localDate])
  @@index([status])
}

// sub tarefas para alcançar a tarefa principal / total
model Subtask {
  id       String  @id @default(cuid())
  ritualId String
  content  String
  done     Boolean @default(false)
  order    Int     @default(0)

  ritual RitualDay @relation(fields: [ritualId], references: [id])

  @@index([ritualId])
  @@index([done])
}

model Note {
  id         String    @id @default(cuid())
  userId     String
  title      String?
  content    String
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  archivedAt DateTime?

  user            User             @relation(fields: [userId], references: [id])
  noteAttachments NoteAttachment[]

  @@index([userId, createdAt])
}

model NoteAttachment {
  id               String   @id @default(cuid())
  noteId           String
  userId           String
  url              String
  secureUrl        String
  publicId         String   @unique
  resourceType     String // image | video | raw | auto (retornado pelo Cloudinary)
  format           String?
  bytes            Int?
  width            Int?
  height           Int?
  duration         Float?
  originalFilename String?
  createdAt        DateTime @default(now())

  note Note @relation(fields: [noteId], references: [id], onDelete: Cascade)

  @@index([noteId, createdAt])
  @@index([userId, createdAt])
}

model AiThread {
  id            String    @id @default(cuid())
  userId        String
  title         String? // opcional: você pode salvar o assunto
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  lastMessageAt DateTime  @default(now())
  deletedAt     DateTime?

  user     User        @relation(fields: [userId], references: [id])
  messages AiMessage[]

  @@index([userId, lastMessageAt])
  @@index([deletedAt])
}

model AiMessage {
  id        String   @id @default(cuid())
  threadId  String
  role      AiRole
  content   String // use TEXT (Postgres) por padrão
  model     String? // opcional: modelo usado na resposta (ex.: "gpt-4o-mini")
  tokens    Int? // opcional: total de tokens
  latencyMs Int? // opcional: métrica simples
  error     String? // opcional: se a chamada falhou
  meta      Json? // opcional: payloads adicionais
  createdAt DateTime @default(now())

  thread AiThread @relation(fields: [threadId], references: [id], onDelete: Cascade)

  @@index([threadId, createdAt])
}

model PushDevice {
  id         String   @id @default(cuid())
  userId     String
  token      String   @unique // FCM registration token
  platform   String // 'ios' | 'android' | 'web'
  appVersion String? // opcional
  disabled   Boolean  @default(false)
  lastSeenAt DateTime @default(now())
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, disabled])
}

// Opcional futuro (não usar no MVP se quiser enxuto):
// model Achievement { ... }  // micro conquistas tipo "5 dias seguidos"
